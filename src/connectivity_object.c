/**
 * Author: Szymon Stolarski
 *
 * template generated by anjay_codegen.py on 2020-05-26 16:31:52
 *
 * LwM2M Object: Connectivity Monitoring
 * ID: 4, URN: urn:oma:lwm2m:oma:4:1.2, Optional, Single
 *
 * This LwM2M Object enables monitoring of parameters related to network
 * connectivity. In this general connectivity Object, the Resources are
 * limited to the most general cases common to most network bearers. It
 * is recommended to read the description, which refers to relevant
 * standard development organizations (e.g. 3GPP, IEEE). The goal of the
 * Connectivity Monitoring Object is to carry information reflecting the
 * more up to date values of the current connection for monitoring
 * purposes. Resources such as Link Quality, Radio Signal Strength, Cell
 * ID are retrieved during connected mode at least for cellular networks.
 */
#include <assert.h>
#include <stdbool.h>
#include <stdint.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_memory.h>

#include "avst_utils.h"

/**
 * Network Bearer: R, Single, Mandatory
 * type: integer, range: 0..50, unit: N/A
 * Indicates the network bearer used for the current LwM2M communication
 * session from the network bearer list below.  The number range is split
 * into three categories: 0 - 20 are Cellular Bearers  21 - 40 are
 * Wireless Bearers  41 - 50 are Wireline Bearers More specifically:  0:
 * GSM cellular network 1: TD-SCDMA cellular network 2: WCDMA cellular
 * network 3: CDMA2000 cellular network 4: WiMAX cellular network 5: LTE-
 * TDD cellular network 6: LTE-FDD cellular network 7: NB-IoT 8 - 20:
 * Reserved for other types of cellular network 21: WLAN network 22:
 * Bluetooth network 23: IEEE 802.15.4 network 24 - 40: Reserved for
 * other types of local wireless network 41: Ethernet 42: DSL 43: PLC 44
 * - 50: reserved for other types of wireline networks.
 */
#define RID_NETWORK_BEARER 0

/**
 * Available Network Bearer: R, Multiple, Mandatory
 * type: integer, range: 0..50, unit: N/A
 * Indicates a list of current available network bearer. Each Resource
 * Instance has a value from the network bearer list.
 */
#define RID_AVAILABLE_NETWORK_BEARER 1

/**
 * Radio Signal Strength: R, Single, Mandatory
 * type: integer, range: N/A, unit: N/A
 * Indicates the average value of the received signal strength indication
 * used in the current network bearer (as indicated by Resource 0 of this
 * Object). The value is expressed in dBm. For the following network
 * bearers the signal strength parameters indicated below are represented
 * by this resource: GSM:    RSSI UMTS:   RSCP LTE:    RSRP NB-IoT: NRSRP
 * For more details on Network Measurement Report, refer to the
 * appropriate Cellular or Wireless Network standards, (e.g. for LTE
 * Cellular Network refer to 3GPP TS 36.133 specification).
 */
#define RID_RADIO_SIGNAL_STRENGTH 2

/**
 * Link Quality: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * This contains received link quality  e.g. LQI for IEEE 802.15.4 (range
 * 0...255), RxQual Downlink for GSM (range 0...7, refer to [3GPP 44.018]
 * for more details on Network Measurement Report encoding), RSRQ for
 * LTE, (refer to [3GPP 36.214]), NRSRQ for NB-IoT (refer to [3GPP
 * 36.214]).
 */
#define RID_LINK_QUALITY 3

/**
 * IP Addresses: R, Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * The IP addresses assigned to the connectivity interface. (e.g. IPv4,
 * IPv6, etc.)
 */
#define RID_IP_ADDRESSES 4

/**
 * Router IP Addresses: R, Multiple, Optional
 * type: string, range: N/A, unit: N/A
 * The IP address of the next-hop IP router, on each of the interfaces
 * specified in resource 4 (IP Addresses). Note: This IP Address doesn't
 * indicate the Server IP address.
 */
#define RID_ROUTER_IP_ADDRESSES 5

/**
 * Link Utilization: R, Single, Optional
 * type: integer, range: 0..100, unit: %
 * The percentage indicating the average utilization of the link to the
 * next-hop IP router.
 */
#define RID_LINK_UTILIZATION 6

/**
 * APN: R, Multiple, Optional
 * type: string, range: N/A, unit: N/A
 * Access Point Name in case Network Bearer Resource is a Cellular
 * Network.
 */
#define RID_APN 7

/**
 * Cell ID: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * Serving Cell ID in case Network Bearer Resource is a Cellular Network.
 * As specified in TS [3GPP 23.003] and in [3GPP. 24.008]. Range
 * (0...65535) in GSM/EDGE UTRAN Cell ID has a length of 28 bits. Cell
 * Identity in WCDMA/TD-SCDMA. Range: (0...268435455). LTE Cell ID has a
 * length of 28 bits. Parameter definitions in [3GPP 25.331].
 */
#define RID_CELL_ID 8

/**
 * SMNC: R, Single, Optional
 * type: integer, range: 0..999, unit: N/A
 * Serving Mobile Network Code. This is applicable when the Network
 * Bearer Resource value is referring to a cellular network. As specified
 * in TS [3GPP 23.003].
 */
#define RID_SMNC 9

/**
 * SMCC: R, Single, Optional
 * type: integer, range: 0..999, unit: N/A
 * Serving Mobile Country Code. This is applicable when the Network
 * Bearer Resource value is referring to a cellular network. As specified
 * in TS [3GPP 23.003].
 */
#define RID_SMCC 10

/**
 * SignalSNR: R, Single, Optional
 * type: integer, range: N/A, unit: dB
 * SINR: Signal to Interference plus Noise Ratio SINR is the ratio of the
 * strength of the received signal to the strength of the received
 * interference signal (noise and interference).
 */
#define RID_SIGNALSNR 11

/**
 * LAC: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * Location Area Code in case Network Bearer Resource is a Cellular
 * Network. As specified in TS [3GPP 23.003] and in [3GPP. 24.008]
 */
#define RID_LAC 12

typedef struct available_network_bearer_instance {
    anjay_riid_t index;
    int32_t available_network_bearer;
} available_network_bearer_instance_t;

typedef struct ip_address_instance {
    anjay_riid_t index;
    char* ip_address;
} ip_address_instance_t;

typedef struct connectivity_monitoring_object_struct {
    const anjay_dm_object_def_t *def;
    anjay_iid_t iid;
    
    // TODO: object state
    int32_t network_bearer;

    bool has_available_network_bearer_instances;
    AVS_LIST(available_network_bearer_instance_t) available_network_bearers;

    int32_t radio_signal_stregnth;

    bool has_ip_addresses;
    AVS_LIST(ip_address_instance_t) ip_addresses;
} connectivity_monitoring_object_t;

static inline connectivity_monitoring_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, connectivity_monitoring_object_t, def);
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_NETWORK_BEARER,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_AVAILABLE_NETWORK_BEARER,
                      ANJAY_DM_RES_RM, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_RADIO_SIGNAL_STRENGTH,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_IP_ADDRESSES,
                      ANJAY_DM_RES_RM, ANJAY_DM_RES_PRESENT);

    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;

    connectivity_monitoring_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

 enum {
        NB_CELLULAR_GSM = 0,
        NB_CELLULAR_TD_SCDMA,
        NB_CELLULAR_WCDMA,
        NB_CELLULAR_CDMA2000,
        NB_CELLULAR_WIMAX,
        NB_CELLULAR_LTE_TDD,
        NB_CELLULAR_LTE_FDD,

        NB_WIRELESS_WLAN = 21,
        NB_WIRELESS_BLUETOOTH,
        NB_WIRELESS_802_15_4,

        NB_WIRED_ETHERNET = 41,
        NB_WIRED_DSL,
        NB_WIRED_PLC
    };



    switch (rid) {
    case RID_NETWORK_BEARER: {
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); 
    }
    case RID_AVAILABLE_NETWORK_BEARER:
        return anjay_ret_i32(ctx, NB_WIRED_ETHERNET);
    case RID_RADIO_SIGNAL_STRENGTH: {
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); 
    }
    case RID_IP_ADDRESSES: {

        char ip_addr[15];
        avst_get_internet_ip_addr(ip_addr);
        return anjay_ret_string(ctx, ip_addr);
    }
    default: {
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
    }
}


static int
list_resource_instances(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t iid,
                           anjay_rid_t rid,
                           anjay_dm_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    switch (rid) {
    case RID_AVAILABLE_NETWORK_BEARER:
        anjay_dm_emit(ctx, 0);       
        return 0;
    case RID_IP_ADDRESSES:
        anjay_dm_emit(ctx, 0);
        return 0;
    default:
        AVS_UNREACHABLE(
                "Attempted to list instances in a single-instance resource");
        return ANJAY_ERR_INTERNAL;
    }
}



static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 4,
    .handlers = {
        .list_instances = anjay_dm_list_instances_SINGLE,

        .list_resources = list_resources,
        .resource_read = resource_read,
        .list_resource_instances = list_resource_instances,


        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP
    }
};

const anjay_dm_object_def_t **connectivity_monitoring_object_create(void) {
    connectivity_monitoring_object_t *obj = (connectivity_monitoring_object_t *) avs_calloc(1, sizeof(connectivity_monitoring_object_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    return &obj->def;
}

void connectivity_monitoring_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        connectivity_monitoring_object_t *obj = get_obj(def);

        avs_free(obj);
    }
}
