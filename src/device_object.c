/**
 * Author: Szymon Stolarski
 *
 * template generated by anjay_codegen.py on 2020-05-26 16:05:21
 *
 * LwM2M Object: Device
 * ID: 3, URN: urn:oma:lwm2m:oma:3:1.1, Mandatory, Single
 *
 * This LwM2M Object provides a range of device related information which
 * can be queried by the LwM2M Server, and a device reboot and factory
 * reset function.
 */
#include <assert.h>
#include <stdbool.h>
#include <stdint.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_memory.h>

#include<time.h>
#include"avst_utils.h"
#include "device_object.h"

/*
* minimal amount of free memory
* when lower - raise OUT_OF_MEMORY error
*/
#define MIN_FREE_MEMORY 1024

/**
 * Manufacturer: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Human readable manufacturer name
 */
#define RID_MANUFACTURER 0

/**
 * Model Number: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * A model identifier (manufacturer specified string)
 */
#define RID_MODEL_NUMBER 1

/**
 * Serial Number: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Serial Number
 */
#define RID_SERIAL_NUMBER 2

/**
 * Firmware Version: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Current firmware version of the Device.The Firmware Management
 * function could rely on this resource.
 */
#define RID_FIRMWARE_VERSION 3

/**
 * Reboot: E, Single, Mandatory
 * type: N/A, range: N/A, unit: N/A
 * Reboot the LwM2M Device to restore the Device from unexpected firmware
 * failure.
 */
#define RID_REBOOT 4

/**
 * Factory Reset: E, Single, Optional
 * type: N/A, range: N/A, unit: N/A
 * Perform factory reset of the LwM2M Device to make the LwM2M Device to
 * go through initial deployment sequence where provisioning and
 * bootstrap sequence is performed. This requires client ensuring post
 * factory reset to have minimal information to allow it to carry out one
 * of the bootstrap methods specified in section 5.2.3.  When this
 * Resource is executed, "De-register" operation MAY be sent to the LwM2M
 * Server(s) before factory reset of the LwM2M Device.
 */
#define RID_FACTORY_RESET 5

/**
 * Available Power Sources: R, Multiple, Optional
 * type: integer, range: 0..7, unit: N/A
 * 0: DC power 1: Internal Battery 2: External Battery 3: Fuel Cell 4:
 * Power over Ethernet 5: USB 6: AC (Mains) power 7: Solar The same
 * Resource Instance ID MUST be used to associate a given Power Source
 * (Resource ID:6) with its Present Voltage (Resource ID:7) and its
 * Present Current (Resource ID:8)
 */
#define RID_AVAILABLE_POWER_SOURCES 6

/**
 * Power Source Voltage: R, Multiple, Optional
 * type: integer, range: N/A, unit: N/A
 * Present voltage for each Available Power Sources Resource Instance.
 * The unit used for this resource is in mV.
 */
#define RID_POWER_SOURCE_VOLTAGE 7

/**
 * Power Source Current: R, Multiple, Optional
 * type: integer, range: N/A, unit: N/A
 * Present current for each Available Power Source. The unit used for
 * this resource is in mA.
 */
#define RID_POWER_SOURCE_CURRENT 8

/**
 * Battery Level: R, Single, Optional
 * type: integer, range: 0..100, unit: %
 * Contains the current battery level as a percentage (with a range from
 * 0 to 100). This value is only valid for the Device internal Battery if
 * present (one Available Power Sources Resource Instance is 1).
 */
#define RID_BATTERY_LEVEL 9

/**
 * Memory Free: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * Estimated current available amount of storage space which can store
 * data and software in the LwM2M Device (expressed in kilobytes).
 */
#define RID_MEMORY_FREE 10

/**
 * Error Code: R, Multiple, Mandatory
 * type: integer, range: 0..8, unit: N/A
 * 0=No error 1=Low battery power 2=External power supply off 3=GPS
 * module failure 4=Low received signal strength 5=Out of memory 6=SMS
 * failure 7=IP connectivity failure 8=Peripheral malfunction  When the
 * single Device Object Instance is initiated, there is only one error
 * code Resource Instance whose value is equal to 0 that means no error.
 * When the first error happens, the LwM2M Client changes error code
 * Resource Instance to any non-zero value to indicate the error type.
 * When any other error happens, a new error code Resource Instance is
 * created. When an error associated with a Resource Instance is no
 * longer present, that Resource Instance is deleted. When the single
 * existing error is no longer present, the LwM2M Client returns to the
 * original no error state where Instance 0 has value 0. This error code
 * Resource MAY be observed by the LwM2M Server. How to deal with LwM2M
 * Clientâ€™s error report depends on the policy of the LwM2M Server.
 */
#define RID_ERROR_CODE 11

/**
 * Reset Error Code: E, Single, Optional
 * type: N/A, range: N/A, unit: N/A
 * Delete all error code Resource Instances and create only one zero-
 * value error code that implies no error, then re-evaluate all error
 * conditions and update and create Resources Instances to capture all
 * current error conditions.
 */
#define RID_RESET_ERROR_CODE 12

/**
 * Current Time: RW, Single, Optional
 * type: time, range: N/A, unit: N/A
 * Current UNIX time of the LwM2M Client. The LwM2M Client should be
 * responsible to increase this time value as every second elapses. The
 * LwM2M Server is able to write this Resource to make the LwM2M Client
 * synchronized with the LwM2M Server.
 */
#define RID_CURRENT_TIME 13

/**
 * UTC Offset: RW, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Indicates the UTC offset currently in effect for this LwM2M Device.
 * UTC+X [ISO 8601].
 */
#define RID_UTC_OFFSET 14

/**
 * Timezone: RW, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Indicates in which time zone the LwM2M Device is located, in IANA
 * Timezone (TZ) database format.
 */
#define RID_TIMEZONE 15

/**
 * Supported Binding and Modes: R, Single, Mandatory
 * type: string, range: N/A, unit: N/A
 * Indicates which bindings and modes are supported in the LwM2M Client.
 * The possible values are those listed in the LwM2M Core Specification.
 */
#define RID_SUPPORTED_BINDING_AND_MODES 16

/**
 * Device Type: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Type of the device (manufacturer specified string: e.g. smart meters /
 * dev Class / ...)
 */
#define RID_DEVICE_TYPE 17

/**
 * Hardware Version: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Current hardware version of the device
 */
#define RID_HARDWARE_VERSION 18

/**
 * Software Version: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Current software version of the device (manufacturer specified
 * string). On elaborated LwM2M device, SW could be split in 2 parts: a
 * firmware one and a higher level software on top. Both pieces of
 * Software are together managed by LwM2M Firmware Update Object (Object
 * ID 5)
 */
#define RID_SOFTWARE_VERSION 19

/**
 * Battery Status: R, Single, Optional
 * type: integer, range: 0..6, unit: N/A
 * This value is only valid for the Device Internal Battery if present
 * (one Available Power Sources Resource Instance value is 1). Battery
 * Status  Meaning Description 0       Normal  The battery is operating
 * normally and not on power. 1       Charging        The battery is
 * currently charging. 2       Charge Complete The battery is fully
 * charged and still on power. 3       Damaged The battery has some
 * problem. 4       Low Battery     The battery is low on charge. 5
 * Not Installed   The battery is not installed. 6       Unknown The
 * battery information is not available.
 */
#define RID_BATTERY_STATUS 20

/**
 * Memory Total: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * Total amount of storage space which can store data and software in the
 * LwM2M Device (expressed in kilobytes).
 */
#define RID_MEMORY_TOTAL 21

/**
 * ExtDevInfo: R, Multiple, Optional
 * type: objlnk, range: N/A, unit: N/A
 * Reference to external "Device" object instance containing information.
 * For example, such an external device can be a Host Device, which is a
 * device into which the Device containing the LwM2M client is embedded.
 * This Resource may be used to retrieve information about the Host
 * Device.
 */
#define RID_EXTDEVINFO 22

     

//structure representing single instance of Multiple instance resource
typedef struct error_code_instance{
    anjay_riid_t index;
    error_code_t error_code;
}error_code_instance_t;

typedef struct device_object_struct {
    const anjay_dm_object_def_t *def;   
    anjay_iid_t iid; 

    int32_t memory_free;
    AVS_LIST(error_code_instance_t) error_codes;
    time_t current_time;
    int32_t (*reboot)(void);
    char* supported_binding_and_modes;
    int32_t memory_total;

    int32_t last_notify_current_time;

    char utc_offset[16];
    char timezone[32];

} device_object_t;



static inline device_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, device_object_t, def);
}


static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    obj->memory_free = 0;    
    AVS_LIST_CLEAR(&obj->error_codes);
    obj->current_time = 0;
    obj->reboot = avst_reboot_device; 
    obj->supported_binding_and_modes = "U"; 
    obj->memory_total = 0;
    obj->last_notify_current_time = 0;
    return 0;
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;
  
    anjay_dm_emit_res(ctx, RID_REBOOT,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_MEMORY_FREE,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_ERROR_CODE,
                      ANJAY_DM_RES_RM, ANJAY_DM_RES_PRESENT);
     anjay_dm_emit_res(ctx, RID_RESET_ERROR_CODE,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);                  
    anjay_dm_emit_res(ctx, RID_CURRENT_TIME,
                    ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_UTC_OFFSET, ANJAY_DM_RES_RW,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_TIMEZONE, ANJAY_DM_RES_RW,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_SUPPORTED_BINDING_AND_MODES,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_MEMORY_TOTAL,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    
    return 0;
}


static int resource_reset(anjay_t *anjay,
                               const anjay_dm_object_def_t *const *obj_ptr,
                               anjay_iid_t iid,
                               anjay_rid_t rid) {
    (void) anjay; // unused

    device_object_t *obj =
            (device_object_t *) get_obj(obj_ptr);

    // free memory associated with old values
    AVS_LIST_CLEAR(&obj->error_codes);
    return 0;
}


static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {

    case RID_MEMORY_FREE:{
        assert(riid == ANJAY_ID_INVALID);

        int32_t memory_free;
        if(avst_get_free_memory(&memory_free)){
            return -1;
        }
        if(memory_free <= MIN_FREE_MEMORY){
            device_object_add_error(&obj->def, OUT_OF_MEMORY);
        }

        return anjay_ret_i32(ctx, memory_free);        

    }
    case RID_ERROR_CODE:{    
        AVS_LIST(const error_code_instance_t) it;
        AVS_LIST_FOREACH(it, obj->error_codes){
            if(it->index == riid){
                return anjay_ret_i32(ctx, it->error_code);
            }
        }
        return ANJAY_ERR_NOT_FOUND;        
    }
    case RID_CURRENT_TIME:{
        assert(riid == ANJAY_ID_INVALID);
       int64_t timestamp;
        if (avs_time_real_to_scalar(&timestamp, AVS_TIME_S, 
                                    avs_time_real_now())) {
            return -1;
        }
        return anjay_ret_i64(ctx, timestamp);
    }
    case RID_SUPPORTED_BINDING_AND_MODES:{
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, obj->supported_binding_and_modes); 
    }
    case RID_MEMORY_TOTAL:{
        assert(riid == ANJAY_ID_INVALID);
        int32_t memory_total;
        if(avst_get_total_memory(&memory_total)){ 
            return -1;   
        }
        return anjay_ret_i32(ctx, memory_total); 
        
    }
    case RID_UTC_OFFSET:{
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, obj->utc_offset);
    }
    case RID_TIMEZONE:{
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, obj->timezone);
    }
    default:{
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
    }
}

static int
read_string(anjay_input_ctx_t *ctx, char *buffer, size_t buffer_size) {
    char *tmp = (char *) avs_malloc(buffer_size);
    if (!tmp) {        
        return -1;
    }
    int result = anjay_get_string(ctx, tmp, buffer_size);
    if (result < 0) {
        avs_free(tmp);
        return result;
    } else if (result == ANJAY_BUFFER_TOO_SHORT) {        
        result = ANJAY_ERR_INTERNAL;
        avs_free(tmp);
        return result;
    }

    memcpy(buffer, tmp, buffer_size);
    result = 0;
    avs_free(tmp);
    return result;    
}

static int resource_write(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_rid_t rid,
                          anjay_riid_t riid,
                          anjay_input_ctx_t *ctx) {
    (void) anjay;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
  case RID_UTC_OFFSET:
        assert(riid == ANJAY_ID_INVALID);
        return read_string(ctx, obj->utc_offset, sizeof(obj->utc_offset));
    case RID_TIMEZONE:
        assert(riid == ANJAY_ID_INVALID);
        return read_string(ctx, obj->timezone, sizeof(obj->timezone));
    default:{
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
    }
}

static int resource_execute(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_execute_ctx_t *arg_ctx) {
    (void) arg_ctx;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_REBOOT:{
        if(obj->reboot()){
            return 0;
        }
        else{
            return ANJAY_ERR_NOT_IMPLEMENTED; 
        }
        
    }
    case RID_RESET_ERROR_CODE:{
        AVS_LIST_CLEAR(&obj->error_codes);
        device_object_add_error(&obj->def, NO_ERROR);
        return 0;
    }
    default:{
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
    }
}

static int list_resource_instances(anjay_t *anjay,
                                   const anjay_dm_object_def_t *const *obj_ptr,
                                   anjay_iid_t iid,
                                   anjay_rid_t rid,
                                   anjay_dm_list_ctx_t *ctx) {
    (void) anjay;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);


    AVS_LIST(error_code_instance_t) it;
    AVS_LIST_FOREACH(it, obj->error_codes){
        anjay_dm_emit(ctx, it->index);
    }

    return 0;  
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 3,
    .handlers = {
        .list_instances = anjay_dm_list_instances_SINGLE,
        .instance_reset = instance_reset,

        .list_resources = list_resources,
        .resource_read = resource_read,
        .resource_write = resource_write,
        .resource_execute = resource_execute,
        .list_resource_instances = list_resource_instances,


        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP
    }
};

/* */

static error_code_instance_t* add_error_instance(device_object_t *obj, const error_code_t error_code){

    AVS_LIST(error_code_instance_t) created =
        AVS_LIST_NEW_ELEMENT(error_code_instance_t);
    if (!created) {
        return NULL;
    }

    //intialisation of a new object
    created->index = AVS_LIST_SIZE(obj->error_codes);
    created->error_code = error_code;

    AVS_LIST(error_code_instance_t) *ptr; 
    AVS_LIST_FOREACH_PTR(ptr, &obj->error_codes) {
        if ((*ptr)->index > created->index) {
            break;
        }   
    }

    AVS_LIST_INSERT(ptr, created);
    return created;
}

static error_code_instance_t* find_error_instance(device_object_t *obj, const error_code_t error_code){

    AVS_LIST(error_code_instance_t) resr;
    AVS_LIST_FOREACH(resr, obj->error_codes) {
        if (resr->error_code == error_code) {
            return resr;
        } 
    }
    return NULL;
}

int device_object_add_error(const anjay_dm_object_def_t **def, const error_code_t error_code){ 

    if (def) {
        device_object_t *obj = get_obj(def);        

        int32_t error_count = AVS_LIST_SIZE(obj->error_codes);

        error_code_instance_t new_error = {
            .index = error_count,
            .error_code = error_code
        };

        error_code_instance_t* last_error = AVS_LIST_TAIL(obj->error_codes);

        //protection against adding NO_ERRO when other error items are in the list
        if(error_count > 0 &&  last_error->error_code == NO_ERROR){
            return -1;
        }

        if(error_count == 1  &&  last_error->error_code == NO_ERROR){
            new_error.index = 0;
            *last_error = new_error;
            return 0;
        }
        else{
            if(find_error_instance(obj, error_code)){
               return 0;
            }
            else{
                return add_error_instance(obj, error_code) ? 0 : -1;
            }      
        }           
    }
    return -1;
}

const anjay_dm_object_def_t **device_object_create(void) {
    device_object_t *obj = (device_object_t *) avs_calloc(1, sizeof(device_object_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    obj->memory_free = 0;    
    AVS_LIST_CLEAR(&obj->error_codes);
    obj->current_time = 0;
    obj->reboot = avst_reboot_device; 
    obj->supported_binding_and_modes = "U"; //UDP is default 
    obj->memory_total = 0;
    obj->last_notify_current_time = 0;
    strcpy(obj->timezone, "Warsaw");
    strcpy(obj->utc_offset, "+2");
    device_object_add_error(&obj->def, NO_ERROR);

    return &obj->def;
}

void device_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        device_object_t *obj = get_obj(def);
        AVS_LIST_CLEAR(&obj->error_codes);
        avs_free(obj);
    }
}

void device_object_notify(anjay_t *anjay, const anjay_dm_object_def_t **def) {
    if (!anjay && !def) {
        return;
    }
    device_object_t *obj = get_obj(def);

    int64_t current_time;
    if (avs_time_real_to_scalar(&current_time, AVS_TIME_S,
                                avs_time_real_now())) {
        return;
    }
    
    if (obj->last_notify_current_time != current_time) {
        if (!anjay_notify_changed(anjay, 3, obj->iid, RID_CURRENT_TIME)) {
            obj->last_notify_current_time= current_time;
        }
    }
}
